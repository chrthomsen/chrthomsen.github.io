
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Fact Tables &#8212; pygrametl 2.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bulk Loading" href="bulkloading.html" />
    <link rel="prev" title="Dimensions" href="dimensions.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fact-tables">
<span id="facttables"></span><h1>Fact Tables<a class="headerlink" href="#fact-tables" title="Permalink to this heading">¶</a></h1>
<p>pygrametl provides multiple classes for representing fact tables. These classes
enable facts to be loaded one at a time, as batches stored in memory, or in
bulk from a file on disk. Support for loading facts with missing information and
then updating them later is also supported. For information about how to load
facts in parallel see <a class="reference internal" href="parallel.html#parallel"><span class="std std-ref">Parallel</span></a>. In the following examples, we use
PostgreSQL as the RDBMS and psycopg2 as the database driver.</p>
<p>All of the following classes are currently implemented in the
<a class="reference internal" href="../api/tables.html#module-pygrametl.tables" title="pygrametl.tables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pygrametl.tables</span></code></a> module.</p>
<section id="facttable">
<h2>FactTable<a class="headerlink" href="#facttable" title="Permalink to this heading">¶</a></h2>
<p>The most basic class for representing a fact table is <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a>.
Before creating a <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a> object, an appropriate table must be
created in the database, and a <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> connection to the database must be
created and wrapped by the class <a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper" title="pygrametl.ConnectionWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectionWrapper</span></code></a>. For more
information about how database connections are used in pygrametl see
<a class="reference internal" href="database.html#database"><span class="std std-ref">Database</span></a>. <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a> constructor must be given the table’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code>, the attributes used as <code class="xref py py-attr docutils literal notranslate"><span class="pre">measures</span></code> in the fact table, and the
attributes referencing dimensions (<code class="xref py py-attr docutils literal notranslate"><span class="pre">keyrefs</span></code>). Be aware that
<a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a> performs an insert in the database whenever the
<a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.insert" title="pygrametl.tables.FactTable.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.insert()</span></code></a> method is called, which can very quickly become a
bottleneck.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psycopg2</span>
<span class="kn">import</span> <span class="nn">pygrametl</span>
<span class="kn">from</span> <span class="nn">pygrametl.tables</span> <span class="kn">import</span> <span class="n">FactTable</span>

<span class="c1"># The actual database connection is handled by a PEP 249 connection</span>
<span class="n">pgconn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;host=&#39;localhost&#39; dbname=&#39;dw&#39; user=&#39;dwuser&#39;</span>
<span class="s2">                          password=&#39;dwpass&#39;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># This ConnectionWrapper will be set as a default and is then implicitly</span>
<span class="c1"># used, but it is stored in conn so transactions can be committed and the</span>
<span class="c1"># connection closed</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">pygrametl</span><span class="o">.</span><span class="n">ConnectionWrapper</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">pgconn</span><span class="p">)</span>

<span class="c1"># This instance of FactTable connects to the table facttable in the</span>
<span class="c1"># database using the default connection wrapper created above</span>
<span class="n">factTable</span> <span class="o">=</span> <span class="n">FactTable</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;facttable&#39;</span><span class="p">,</span>
    <span class="n">measures</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">],</span>
    <span class="n">keyrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;storeid&#39;</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The above example shows the three step process needed to connect an instance of
<a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a> to an existing database table. Firstly, a <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a>
connection to the database is created. Then an instance of
<a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper" title="pygrametl.ConnectionWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectionWrapper</span></code></a> is created to provide a uniform interface to all
types of database connections supported by pygrametl. The instance of
<a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper" title="pygrametl.ConnectionWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectionWrapper</span></code></a> is also set as the default database connection to
use for this ETL flow. Lastly, a <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a> is created as a
representation of the actual database table.</p>
<p>Operations on the fact table are done using three methods:
<a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.insert" title="pygrametl.tables.FactTable.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.insert()</span></code></a> inserts new facts directly into the fact table when
they are passed to the method. <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.lookup" title="pygrametl.tables.FactTable.lookup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.lookup()</span></code></a> returns a fact if the
database contains one with the given combination of keys referencing the
dimensions. <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.ensure" title="pygrametl.tables.FactTable.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.ensure()</span></code></a> combines <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.lookup" title="pygrametl.tables.FactTable.lookup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.lookup()</span></code></a> and
<a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable.insert" title="pygrametl.tables.FactTable.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FactTable.insert()</span></code></a> by ensuring that a fact does not exist before
inserting it. An example of each function and the automatic name mapping can be
seen below, where the fact table from the last example is reused.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psycopg2</span>
<span class="kn">import</span> <span class="nn">pygrametl</span>
<span class="kn">from</span> <span class="nn">pygrametl.tables</span> <span class="kn">import</span> <span class="n">FactTable</span>

<span class="c1"># The actual database connection is handled by a PEP 249 connection</span>
<span class="n">pgconn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;host=&#39;localhost&#39; dbname=&#39;dw&#39; user=&#39;dwuser&#39;</span>
<span class="s2">                          password=&#39;dwpass&#39;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># This ConnectionWrapper will be set as a default and is then implicitly</span>
<span class="c1"># used, but it is stored in conn so transactions can be committed and the</span>
<span class="c1"># connection closed</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">pygrametl</span><span class="o">.</span><span class="n">ConnectionWrapper</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">pgconn</span><span class="p">)</span>

<span class="c1"># This instance of FactTable connects to the table facttable in the</span>
<span class="c1"># database using the default connection wrapper created above</span>
<span class="n">factTable</span> <span class="o">=</span> <span class="n">FactTable</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;facttable&#39;</span><span class="p">,</span>
    <span class="n">measures</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">],</span>
    <span class="n">keyrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;storeid&#39;</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">])</span>

<span class="c1"># A list of facts ready to inserted into the fact table</span>
<span class="n">facts</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">}]</span>

<span class="c1"># The facts can be inserted using the insert method</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
    <span class="n">factTable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="c1"># Lookup returns the keys and measures given only the keys</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">factTable</span><span class="o">.</span><span class="n">lookup</span><span class="p">({</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>

<span class="c1"># Ensure should be used when loading facts that might already be loaded</span>
<span class="n">newFacts</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;itemid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;itemid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;itemid&#39;</span><span class="p">:</span>  <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">150</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;itemid&#39;</span><span class="p">:</span>  <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}]</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">newFacts</span><span class="p">:</span>
    <span class="c1"># The second argument forces ensure to not only match the keys for facts</span>
    <span class="c1"># to be considered equal, but also checks if the measures are the same</span>
    <span class="c1"># for facts with the same key, and if not raises a ValueError. The third</span>
    <span class="c1"># argument renames itemid to productid using a name mapping</span>
    <span class="n">factTable</span><span class="o">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="s1">&#39;itemid&#39;</span><span class="p">})</span>
<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="batchfacttable">
<h2>BatchFactTable<a class="headerlink" href="#batchfacttable" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="../api/tables.html#pygrametl.tables.BatchFactTable" title="pygrametl.tables.BatchFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchFactTable</span></code></a> loads facts into the fact table in batches instead of
one at a time like <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a>. Thus reducing the number of round trips
to the database which improves the performance of the ETL flow. The size of each
batch is determined by the <code class="xref py py-attr docutils literal notranslate"><span class="pre">batchsize</span></code> parameter added to the class’s
constructor. <a class="reference internal" href="../api/tables.html#pygrametl.tables.BatchFactTable" title="pygrametl.tables.BatchFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchFactTable</span></code></a> loads each batch using either the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code> method specified in <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> or a single SQL <code class="docutils literal notranslate"><span class="pre">INSERT</span> <span class="pre">INTO</span>
<span class="pre">facttable</span> <span class="pre">VALUES(...)</span></code> statement depending on the value passed to
<code class="xref py py-attr docutils literal notranslate"><span class="pre">usemultirow</span></code> in the classes constructor. The
<a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper.commit" title="pygrametl.ConnectionWrapper.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionWrapper.commit()</span></code></a> method must be called after all facts have
been inserted into the fact table to both ensure that the last batch is loaded
into the database from memory and that the transaction is committed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both <code class="xref py py-meth docutils literal notranslate"><span class="pre">BatchFactTable.lookup()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">BatchFactTable.ensure()</span></code>
force the current batch of facts to be an inserted. This is to keep
them consistent with all of facts inserted into the fact table. Thus
using these methods can reduce the benefit of batching insertions.</p>
</div>
</section>
<section id="bulkfacttable">
<h2>BulkFactTable<a class="headerlink" href="#bulkfacttable" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="../api/tables.html#pygrametl.tables.BulkFactTable" title="pygrametl.tables.BulkFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BulkFactTable</span></code></a> also inserts facts in batches but writes the facts to a
temporary file instead of keeping them in memory. Thus the size of a batch is
limited by the size of the disk instead of the amount of memory available.
However, this prevents <code class="xref py py-meth docutils literal notranslate"><span class="pre">BulkFactTable.lookup()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">BulkFactTable.ensure()</span></code> from being implemented efficiently, so these
methods are not available. Like for <a class="reference internal" href="../api/tables.html#pygrametl.tables.BatchFactTable" title="pygrametl.tables.BatchFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchFactTable</span></code></a>, the method
<a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper.commit" title="pygrametl.ConnectionWrapper.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConnectionWrapper.commit()</span></code></a> must be called to ensure that the last batch
of facts is loaded into the database. Multiple additional parameters have been
added to the class’s constructor to provide control over the temporary file used
to store facts, such as what delimiters to use and the number of facts to be
bulk loaded in each batch. All of these parameters have a default value except
for <code class="xref py py-attr docutils literal notranslate"><span class="pre">bulkloader</span></code>. This parameter must be passed a function that will be
called for each batch of facts to be loaded. This is necessary as the exact way
to perform bulk loading differs from RDBMS to RDBMS.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">func(name,</span> <span class="pre">attributes,</span> <span class="pre">fieldsep,</span> <span class="pre">rowsep,</span> <span class="pre">nullval,</span> <span class="pre">filehandle):</span></span></dt>
<dd><p>Required signature of a function bulk loading data from a file into an RDBMS
in pygrametl. For more information about bulk loading see
<a class="reference internal" href="bulkloading.html#bulkloading"><span class="std std-ref">Bulk Loading</span></a>.</p>
<p><strong>Arguments:</strong></p>
<ul class="simple">
<li><p>name: the name of the fact table in the data warehouse.</p></li>
<li><p>attributes: a list containing both the sequence of attributes constituting
the primary key of the fact table, as well as the measures.</p></li>
<li><p>fieldsep: the string used to separate fields in the temporary file.</p></li>
<li><p>rowsep: the string used to separate rows in the temporary file.</p></li>
<li><p>nullval: if the <a class="reference internal" href="../api/tables.html#pygrametl.tables.BulkFactTable" title="pygrametl.tables.BulkFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BulkFactTable</span></code></a> was passed a string to substitute
None values with, then it will be passed, if not then None is passed.</p></li>
<li><p>filehandle: either the name of the file or the file object itself,
depending upon the value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">BulkFactTable.usefilename</span></code>. Using
the filename is necessary if the bulk loading is invoked through SQL
(instead of directly via a method on the PEP249 driver). It is also
necessary if the bulkloader runs in another process.</p></li>
</ul>
</dd></dl>

<p>In the following example, a <a class="reference internal" href="../api/tables.html#pygrametl.tables.BulkFactTable" title="pygrametl.tables.BulkFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">BulkFactTable</span></code></a> is used to bulk load facts
into a data warehouse using function <code class="xref py py-func docutils literal notranslate"><span class="pre">pgbulkloader()</span></code>. For information about
how to bulk loading data into other RDBMSs see <a class="reference internal" href="bulkloading.html#bulkloading"><span class="std std-ref">Bulk Loading</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psycopg2</span>
<span class="kn">import</span> <span class="nn">pygrametl</span>
<span class="kn">from</span> <span class="nn">pygrametl.tables</span> <span class="kn">import</span> <span class="n">BulkFactTable</span>

<span class="n">pgconn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;host=&#39;localhost&#39; dbname=&#39;dw&#39; user=&#39;dwuser&#39;</span>
<span class="s2">                          password=&#39;dwpass&#39;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">pygrametl</span><span class="o">.</span><span class="n">ConnectionWrapper</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">pgconn</span><span class="p">)</span>

<span class="n">facts</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;storeid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span>  <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">}]</span>


<span class="c1"># This function bulk loads a file into PostgreSQL using psycopg2</span>
<span class="k">def</span> <span class="nf">pgbulkloader</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">fieldsep</span><span class="p">,</span> <span class="n">rowsep</span><span class="p">,</span> <span class="n">nullval</span><span class="p">,</span> <span class="n">filehandle</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="c1"># psycopg2 does not accept the default value used to represent NULL</span>
    <span class="c1"># by BulkDimension, which is None. Here this is ignored as we have no</span>
    <span class="c1"># NULL values that we wish to substitute for a more descriptive value</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">copy_from</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">filehandle</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">fieldsep</span><span class="p">,</span>
                     <span class="n">columns</span><span class="o">=</span><span class="n">attributes</span><span class="p">)</span>


<span class="c1"># The bulk loading function must be passed to BulkFactTable&#39;s constructor</span>
<span class="n">factTable</span> <span class="o">=</span> <span class="n">BulkFactTable</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;facttable&#39;</span><span class="p">,</span>
    <span class="n">measures</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">],</span>
    <span class="n">keyrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;storeid&#39;</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">,</span> <span class="s1">&#39;dateid&#39;</span><span class="p">],</span>
    <span class="n">bulkloader</span><span class="o">=</span><span class="n">pgbulkloader</span><span class="p">)</span>

<span class="c1"># commit() and close() must be called to ensure that all facts have been</span>
<span class="c1"># inserted into the database and that the connection is closed correctly</span>
<span class="c1">#  afterward</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
    <span class="n">factTable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="accumulatingsnapshotfacttable">
<h2>AccumulatingSnapshotFactTable<a class="headerlink" href="#accumulatingsnapshotfacttable" title="Permalink to this heading">¶</a></h2>
<p><a class="reference internal" href="../api/tables.html#pygrametl.tables.AccumulatingSnapshotFactTable" title="pygrametl.tables.AccumulatingSnapshotFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable</span></code></a> represents a fact table where facts are
updated as a process evolves. Typically different date references (OrderDate,
PaymentDate, ShipDate, DeliveryDate, etc.) are set when they become known.
Measures (e.g., measuring the lag between the different dates) are also often
set as they become available. Like for <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a>, the class
<a class="reference internal" href="../api/tables.html#pygrametl.tables.AccumulatingSnapshotFactTable" title="pygrametl.tables.AccumulatingSnapshotFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable</span></code></a> performs an insert in the database
whenever the <code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.insert()</span></code> method is called. The
following example illustrates how to create the class:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psycopg2</span>
<span class="kn">import</span> <span class="nn">pygrametl</span>
<span class="kn">from</span> <span class="nn">pygrametl.tables</span> <span class="kn">import</span> <span class="n">AccumulatingSnapshotFactTable</span>

<span class="c1"># The actual database connection is handled by a PEP 249 connection</span>
<span class="n">pgconn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;host=&#39;localhost&#39; dbname=&#39;dw&#39; user=&#39;dwuser&#39;</span>
<span class="s2">                          password=&#39;dwpass&#39;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># This ConnectionWrapper will be set as a default and is then implicitly</span>
<span class="c1"># used, but it is stored in conn so transactions can be committed and the</span>
<span class="c1"># connection closed</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">pygrametl</span><span class="o">.</span><span class="n">ConnectionWrapper</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">pgconn</span><span class="p">)</span>


<span class="c1"># A factexpander can be used to modify a row only if it has been updated, note</span>
<span class="c1"># that we only ignore namemapping for brevity, production code should use it</span>
<span class="k">def</span> <span class="nf">computelag</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">namemapping</span><span class="p">,</span> <span class="n">updated</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;shipmentdateid&#39;</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentlag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentdateid&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;deliverydateid&#39;</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;deliverylag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;deliverydate&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentdateid&#39;</span><span class="p">]</span>


<span class="c1"># This instance of AccumulatingSnapshotFactTable connects to the table</span>
<span class="c1"># orderprocessing in the database using the connection created above</span>
<span class="n">asft</span> <span class="o">=</span> <span class="n">AccumulatingSnapshotFactTable</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;orderprocessing&#39;</span><span class="p">,</span>
    <span class="n">keyrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;orderid&#39;</span><span class="p">,</span> <span class="s1">&#39;customerid&#39;</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">],</span>
    <span class="n">otherrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">,</span> <span class="s1">&#39;shipmentdateid&#39;</span><span class="p">,</span> <span class="s1">&#39;deliverydateid&#39;</span><span class="p">],</span>
    <span class="n">measures</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;shipmentlag&#39;</span><span class="p">,</span> <span class="s1">&#39;deliverylag&#39;</span><span class="p">],</span>
    <span class="n">factexpander</span><span class="o">=</span><span class="n">computelag</span><span class="p">)</span>
</pre></div>
</div>
<p>Firstly a <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> connection is created to perform the actual database
operations, then an instance of the <a class="reference internal" href="../api/pygrametl.html#pygrametl.ConnectionWrapper" title="pygrametl.ConnectionWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectionWrapper</span></code></a> is created as a
uniform wrapper around the <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> connection which is set as the default database
connection for this ETL flow. Then a user-defined function to compute lag measures
is defined. Lastly, an <a class="reference internal" href="../api/tables.html#pygrametl.tables.AccumulatingSnapshotFactTable" title="pygrametl.tables.AccumulatingSnapshotFactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable</span></code></a> is created.</p>
<p>As stated <code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.insert()</span></code> inserts new facts
directly into the fact table when they are passed to the method.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.lookup()</span></code> checks if the database contains a
fact with the given combination of keys referencing the dimensions. These
methods behave in the same way as in <a class="reference internal" href="../api/tables.html#pygrametl.tables.FactTable" title="pygrametl.tables.FactTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">FactTable</span></code></a>. The method
<a class="reference internal" href="../api/tables.html#pygrametl.tables.AccumulatingSnapshotFactTable.update" title="pygrametl.tables.AccumulatingSnapshotFactTable.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.update()</span></code></a>, will based on the <code class="xref py py-attr docutils literal notranslate"><span class="pre">keyrefs</span></code>,
find the fact and update it if there are any differences in <code class="xref py py-attr docutils literal notranslate"><span class="pre">otherrefs</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">measures</span></code>. The method <a class="reference internal" href="../api/tables.html#pygrametl.tables.AccumulatingSnapshotFactTable.ensure" title="pygrametl.tables.AccumulatingSnapshotFactTable.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.ensure()</span></code></a>
checks if the row it is given, already exists in the database table. If it does
not exist, it is immediately inserted. If it exists, the method will see if some
of the values for <code class="xref py py-attr docutils literal notranslate"><span class="pre">otherrefs</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">measures</span></code> have been updated in the
passed row. If so, it will update the row in the database. Before that, it will,
however, run the <code class="xref py py-func docutils literal notranslate"><span class="pre">factexpander()</span></code> if one was given to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">AccumulatingSnapshotFactTable.__init__()</span></code> when the object was created.
Note that the generated SQL for lookups and updates will use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">keyrefs</span></code>
in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause and an index on them should be considered. An example of
how to use the class can be seen below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">psycopg2</span>
<span class="kn">import</span> <span class="nn">pygrametl</span>
<span class="kn">from</span> <span class="nn">pygrametl.tables</span> <span class="kn">import</span> <span class="n">AccumulatingSnapshotFactTable</span>

<span class="c1"># The actual database connection is handled by a PEP 249 connection</span>
<span class="n">pgconn</span> <span class="o">=</span> <span class="n">psycopg2</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;host=&#39;localhost&#39; dbname=&#39;dw&#39; user=&#39;dwuser&#39;</span>
<span class="s2">                          password=&#39;dwpass&#39;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># A factexpander can be used to modify a row only if it has been updated, note</span>
<span class="c1"># that we only ignore namemapping for brevity, production code should use it</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">pygrametl</span><span class="o">.</span><span class="n">ConnectionWrapper</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">pgconn</span><span class="p">)</span>


<span class="c1"># A factexpander can be used to modify a row only if it has been updated, note</span>
<span class="c1"># that we only ignore namemapping for brevity, production code should use it</span>
<span class="k">def</span> <span class="nf">computelag</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">namemapping</span><span class="p">,</span> <span class="n">updated</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">&#39;shipmentdateid&#39;</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentlag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentdateid&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;deliverydateid&#39;</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="n">row</span><span class="p">[</span><span class="s1">&#39;deliverylag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;deliverydate&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;shipmentdateid&#39;</span><span class="p">]</span>


<span class="c1"># This instance of AccumulatingSnapshotFactTable connects to the table</span>
<span class="c1"># orderprocessing in the database using the connection created above</span>
<span class="n">asft</span> <span class="o">=</span> <span class="n">AccumulatingSnapshotFactTable</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;orderprocessing&#39;</span><span class="p">,</span>
    <span class="n">keyrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;orderid&#39;</span><span class="p">,</span> <span class="s1">&#39;customerid&#39;</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">],</span>
    <span class="n">otherrefs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">,</span> <span class="s1">&#39;shipmentdateid&#39;</span><span class="p">,</span> <span class="s1">&#39;deliverydateid&#39;</span><span class="p">],</span>
    <span class="n">measures</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;shipmentlag&#39;</span><span class="p">,</span> <span class="s1">&#39;deliverylag&#39;</span><span class="p">],</span>
    <span class="n">factexpander</span><span class="o">=</span><span class="n">computelag</span><span class="p">)</span>

<span class="c1"># A list of facts that are ready to inserted into the fact table</span>
<span class="n">facts</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;orderid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;customerid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;orderid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;customerid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">},</span>
         <span class="p">{</span><span class="s1">&#39;orderid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;customerid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;productid&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">}]</span>

<span class="c1"># The facts can be inserted using the ensure method. (If we had used the</span>
<span class="c1"># insert method instead, we should have made sure the facts above had a</span>
<span class="c1"># value for each attribute in the fact table. When using ensure, missing</span>
<span class="c1"># attributes will be set to None before an insertion.)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
    <span class="n">asft</span><span class="o">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="c1"># Now assume that the the orders get paid and shipped</span>
<span class="n">facts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">facts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;shipmentdateid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">14</span>
<span class="n">facts</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;paymentdateid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span>

<span class="c1"># Update the accumulating fact table in the DW</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
    <span class="n">asft</span><span class="o">.</span><span class="n">ensure</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>  <span class="c1"># will call computelag and do the needed updates</span>

<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pygrametl</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/install.html">Install Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/beginner.html">Beginner Guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasources.html">Data Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimensions.html">Dimensions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Fact Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="bulkloading.html">Bulk Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="jython.html">Jython</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/pygrametl.html">pygrametl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/datasources.html">datasources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tables.html">tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/parallel.html">parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/jdbcconnectionwrapper.html">JDBCConnectionWrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/jythonmultiprocessing.html">jythonmultiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/aggregators.html">aggregators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/steps.html">steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/fifodict.html">FIFODict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/drawntabletesting.html">drawntabletesting</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="dimensions.html" title="previous chapter">Dimensions</a></li>
      <li>Next: <a href="bulkloading.html" title="next chapter">Bulk Loading</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009 - 2022, Aalborg University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/examples/facttables.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>