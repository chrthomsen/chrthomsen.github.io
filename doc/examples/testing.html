
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Drawn Table Testing &#8212; pygrametl 2.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pygrametl" href="../api/pygrametl.html" />
    <link rel="prev" title="Jython" href="jython.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="drawn-table-testing">
<span id="testing"></span><h1>Drawn Table Testing<a class="headerlink" href="#drawn-table-testing" title="Permalink to this heading">¶</a></h1>
<p>pygrametl provides the Drawn Table abstraction to simplify testing. A Drawn
Table is a string-based representation of a database table. It is implemented in
the Drawn Table Testing (DTT) module, but this <em>does not</em> mean that the user
necessarily must implement the ETL flow itself with pygrametl or in Python – the
ETL flow can be implemented using any programming language or program, including
GUI-based ETL tools. First, the functionality provided by DTT is described, then
how DTT can be used as a Python package (i.e., together with user-written Python
code such as unit tests), and last how DTT can be used as a stand-alone tool
that provides the same functionality without requiring the users to implement
their tests using Python code.</p>
<section id="the-table-class">
<h2>The Table Class<a class="headerlink" href="#the-table-class" title="Permalink to this heading">¶</a></h2>
<p>The Drawn Table abstraction is implemented by the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> class. To
create an instance, a name for the table must be given as well as a
<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> with the Drawn Table. Further, a <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> representing
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> can optionally be given as well as a prefix to be used for variables
(see <a class="reference internal" href="#sec-variables"><span class="std std-ref">Variables</span></a>). The Drawn Table is then parsed by the following
rules: The first row (called the “header”) contains <code class="docutils literal notranslate"><span class="pre">name:type</span></code> pairs for
each column with each pair surrounded by vertical pipes. After a type, <code class="docutils literal notranslate"><span class="pre">(pk)</span></code>
can be specified to make a column (part of) the primary key. <code class="docutils literal notranslate"><span class="pre">UNIQUE</span></code> and
<code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">NULL</span></code> are also supported and must be defined in the same manner as a
primary key. If multiple constraints are defined for one column, they must be
separated by a comma. Foreign keys are also supported and will be explained
later. A valid header is, e.g., <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">bid:int</span> <span class="pre">(pk)</span> <span class="pre">|</span> <span class="pre">title:text</span> <span class="pre">|</span> <span class="pre">genre:text</span> <span class="pre">|</span></code>.
If the table should hold any data, the header must be followed by a delimiter
line containing only vertical pipes, spaces, and dashes (<code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">--</span> <span class="pre">|</span> <span class="pre">--</span> <span class="pre">|</span></code>) and then
each row follows on a line of its own. Columns must be given in the same order
as in the header and must be separated by pipes. For string values, any
surrounding spaces are trimmed away. A Drawn Table is also a valid table in
<a class="reference external" href="https://github.github.com/gfm/#tables-extension-">GitHub Flavored Markdown</a>.
An example is given below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pygrametl.drawntabletesting</span> <span class="k">as</span> <span class="nn">dtt</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">connectionwrapper</span><span class="p">()</span>

<span class="n">table</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| bid:int (pk) | title:text            | genre:text |</span>
<span class="s2">| ------------ | --------------------- | ---------- |</span>
<span class="s2">| 1            | Unknown               | Unknown    |</span>
<span class="s2">| 2            | Nineteen Eighty-Four  | Novel      |</span>
<span class="s2">| 3            | Calvin and Hobbes One | Comic      |</span>
<span class="s2">| 4            | Calvin and Hobbes Two | Comic      |</span>
<span class="s2">| 5            | The Silver Spoon      | Cookbook   |&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">table</span><span class="o">.</span><span class="n">ensure</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, a Drawn Table’s rows can be loaded from an external source by
providing either a path to a file or an <code class="xref py py-class docutils literal notranslate"><span class="pre">iterable</span></code> to the constructor’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">loadFrom</span></code> parameter. The file must contain a Drawn Table without a
header and the <code class="xref py py-class docutils literal notranslate"><span class="pre">iterable</span></code> must yield <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>s mapping from
column names to values. Data can thus be loaded from files, databases, etc.
at the cost of the test not being self-contained.</p>
<p>After a <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance is created, its <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.ensure" title="pygrametl.drawntabletesting.Table.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensure()</span></code></a> method can be invoked. This will determine if a table with
the same name and rows exists in the test database and otherwise create it (or
raise an error if it contains other rows). The <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.reset" title="pygrametl.drawntabletesting.Table.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> creates and
fills the table even if it already exists, while <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.create" title="pygrametl.drawntabletesting.Table.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> creates the
table without inserting any data into it. Finally, the SQL statement generated
by the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance can be retrieved using the methods
<a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.getSQLToCreate" title="pygrametl.drawntabletesting.Table.getSQLToCreate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getSQLToCreate()</span></code></a> and <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.getSQLToInsert" title="pygrametl.drawntabletesting.Table.getSQLToInsert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getSQLToInsert()</span></code></a>. By default, DTT uses
an in-memory SQLite database to run all tests against as it is very fast and
does not require any installation or configuration. It is thus a good choice to
use for testing ETL flows during development. Another RDBMS can be used by
calling <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.connectionwrapper" title="pygrametl.drawntabletesting.connectionwrapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">drawntabletesting.connectionwrapper()</span></code></a> with a PEP 249
connector.</p>
<p>Multiple different tables in the database can be represented using multiple
instances of <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>. In such situations, foreign keys constraints are
often required. In DTT, foreign keys are defined in the same manner as the
other constraints and require that users specify <code class="docutils literal notranslate"><span class="pre">fk</span> <span class="pre">target(att)</span></code> where
<code class="docutils literal notranslate"><span class="pre">target</span></code> is the name of the referenced table and <code class="docutils literal notranslate"><span class="pre">att</span></code> is the referenced
column. An example using foreign keys to connect <code class="docutils literal notranslate"><span class="pre">book</span></code> and <code class="docutils literal notranslate"><span class="pre">genre</span></code> can be
seen below. All foreign key constraints are enforced by the RDMBS managing the
test database.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pygrametl.drawntabletesting</span> <span class="k">as</span> <span class="nn">dtt</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">connectionwrapper</span><span class="p">()</span>

<span class="n">genre</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;genre&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| gid:int (pk) | genre:text |</span>
<span class="s2">| ------------ | ---------- |</span>
<span class="s2">| 1            | Unknown    |</span>
<span class="s2">| 2            | Novel      |</span>
<span class="s2">| 3            | Comic      |</span>
<span class="s2">| 4            | Cookbook   |&quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">book</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| bid:int (pk) | title:text             | gid:int (fk genre(gid)) |</span>
<span class="s2">| ------------ | ---------------------- | ----------------------- |</span>
<span class="s2">| 1            | Unknown                | 1                       |</span>
<span class="s2">| 2            | Nineteen Eighty-Four   | 2                       |</span>
<span class="s2">| 3            | Calvin and Hobbes One  | 3                       |</span>
<span class="s2">| 4            | Calvin and Hobbes Two  | 3                       |</span>
<span class="s2">| 5            | The Silver Spoon       | 4                       |&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instances are immutable once created. Typically, the
postcondition is, however, similar to the precondition except for a few added
or updated rows. In DTT it is simple to create a new <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance from
an existing one by using the <cite>+</cite> operator.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">newtable1</span> <span class="o">=</span> <span class="n">book</span> <span class="o">+</span> <span class="s2">&quot;| 6 | Metro 2033 | 2 |&quot;</span> <span class="o">+</span> <span class="s2">&quot;| 7 | Metro 2034 | 2 |&quot;</span>
</pre></div>
</div>
<p>A new instance is also created when one of the rows is updated. This is done by
calling the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.update" title="pygrametl.drawntabletesting.Table.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> method. For example, the first
row in <cite>table</cite> can be changed with the line:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">newtable2</span> <span class="o">=</span> <span class="n">book</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;| -1 | Unknown | -1 |&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that a new instance of <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is not represented in the test
database unless its <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.ensure" title="pygrametl.drawntabletesting.Table.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensure()</span></code></a> method is invoked. By making
<a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instances immutable and creating new instances when they are
modified, it becomes very easy to reuse the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance
representing the precondition for multiple tests, and then as part of each test
create a new instance with the postcondition based on it.  After a number of
additions and/or updates, it can be useful to get all modified rows. This is
done using the method <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.additions" title="pygrametl.drawntabletesting.Table.additions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">additions()</span></code></a>. For example, a test case where the
ETL flow is executed for the new rows is shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_canInsertIntoBookDimensionTable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">table</span> <span class="o">+</span> <span class="s2">&quot;| 6 | Metro 2033 | 2 |&quot;</span> \
                     <span class="o">+</span> <span class="s2">&quot;| 7 | Metro 2034 | 2 |&quot;</span>
    <span class="n">newrows</span> <span class="o">=</span> <span class="n">expected</span><span class="o">.</span><span class="n">additions</span><span class="p">()</span>
    <span class="n">etl</span><span class="o">.</span><span class="n">executeETLFlow</span><span class="p">(</span><span class="n">newrows</span><span class="p">)</span>
    <span class="n">expected</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">()</span>
</pre></div>
</div>
<p>For the code above, <code class="xref py py-attr docutils literal notranslate"><span class="pre">expected</span></code> defines how the user expects the database
state to become, but it is not the DTT framework that puts the database in this
state. The database is modified by the ETL flow invoked by the user-provided
<code class="xref py py-attr docutils literal notranslate"><span class="pre">etl.executeETLFlow(newrows)</span></code> on Line 5. This method could, e.g., spawn a
new process in which the user’s ETL tool runs. It is thus <em>not</em> a requirement
that the user’s ETL flow is implemented in Python despite the tests being so.
Using these features, DTT makes it simple to define the state of a database
before a test is executed, and the rows the ETL flow should load. However, for
the automatic test to be of any use, it is necessary to validate that the state
of the database after the ETL flow has finished. This is done using assertions
as shown on Line 6.</p>
</section>
<section id="assertions">
<h2>Assertions<a class="headerlink" href="#assertions" title="Permalink to this heading">¶</a></h2>
<p>DTT offers multiple assertions to check the state of a database table.
At the moment, the methods <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertEqual" title="pygrametl.drawntabletesting.Table.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>, <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertDisjoint" title="pygrametl.drawntabletesting.Table.assertDisjoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDisjoint()</span></code></a>,
and <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertSubset" title="pygrametl.drawntabletesting.Table.assertSubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSubset()</span></code></a> are implemented in DTT. When
<a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertEqual" title="pygrametl.drawntabletesting.Table.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> is called as shown above, DTT verifies that
the table in the test database contains the expected rows (and only those) and
if not, raises an <code class="xref py py-class docutils literal notranslate"><span class="pre">AssertionError</span></code> and provides an easy-to-read
explanation of why the test failed as shown below.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>AssertionError: book&#39;s rows differ from the rows in the database.
Drawn Table:
  | bid:int (pk) | title:text            | genre:text |
  <span class="o">|</span> ------------ | --------------------- | ---------- |
  <span class="o">|</span> 1            | Unknown               | Unknown    |
  <span class="o">|</span> 2            | Nineteen Eighty-Four  | Novel      |
  <span class="o">|</span> 3            | Calvin and Hobbes One | Comic      |
  <span class="o">|</span> 4            | Calvin and Hobbes Two | Comic      |
  <span class="o">|</span> 5            | The Silver Spoon      | Cookbook   |

Database Table:
  | bid:int (pk) | title:text            | genre:text |
  <span class="o">|</span> ------------ | --------------------- | ---------- |
  <span class="o">|</span> 1            | Unknown               | Unknown    |
  <span class="o">|</span> 2            | Nineteen Eighty-Four  | Novel      |
  <span class="o">|</span> 3            | Calvin and Hobbes One | Comic      |
  <span class="o">|</span> 4            | Calvin and Hobbes Two | Cookbook   |
  <span class="o">|</span> 5            | The Silver Spoon      | Cookbook   |

Violations:
  | bid:int (pk) | title:text            | genre:text |
  <span class="o">|</span> ------------ | --------------------- | ---------- |
E | 4            | Calvin and Hobbes Two | Comic      |
  |              |                       |            |
D | 4            | Calvin and Hobbes Two | Cookbook   |
</pre></div>
</div>
<p>In this example, the part of the ETL flow loading the <code class="docutils literal notranslate"><span class="pre">book</span></code> table contains a
bug. The <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance in the test specifies that the dimension
should contain a row for unknown books and four rows with known books (see the
expected state in the top of the output). However, the user’s ETL code wrongly
added <code class="docutils literal notranslate"><span class="pre">Calvin</span> <span class="pre">and</span> <span class="pre">Hobbes</span> <span class="pre">Two</span></code> as a <code class="docutils literal notranslate"><span class="pre">Cookbook</span></code> instead of as a <code class="docutils literal notranslate"><span class="pre">Comic</span></code> (see
the middle table in the output). To help the user quickly identify exactly what
rows do not match, DTT prints the rows violating the assertion which for
equality is the difference between the two drawn table and the database table
(bottom). The expected rows (i.e., those in the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance) are
prefixed by an <code class="docutils literal notranslate"><span class="pre">E</span></code> and the rows in the database table are prefixed by a <code class="docutils literal notranslate"><span class="pre">D</span></code>.
The detailed information provided by <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertEqual" title="pygrametl.drawntabletesting.Table.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> can be disabled, by
setting the optional parameter <code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">False</span></code>. Note that
the orders of the rows are allowed to differ between the Drawn Table and the
database table without causing the test to fail.</p>
<p>When <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertDisjoint" title="pygrametl.drawntabletesting.Table.assertDisjoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDisjoint()</span></code></a> is called on a <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance, it is
asserted that none of the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>’s rows are present in the database
table. In this way it is also possible to assert that something <em>is not</em> in the
database table, e.g., to test a filter or to check for the absence of erroneous
rows that previously fixed bugs wrongly added. When <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertSubset" title="pygrametl.drawntabletesting.Table.assertSubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSubset()</span></code></a> is
called, it is asserted that all the <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>’s rows are present in the
database table which, however, may contain more rows which the user then does
not have to specify. <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.assertSubset" title="pygrametl.drawntabletesting.Table.assertSubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSubset()</span></code></a> makes it easy to define a small set
of rows that can be compared to a table with so many rows that they cannot be
effectively embedded in the test itself. For example, it can easily be used to
test if the leap day <code class="docutils literal notranslate"><span class="pre">2020-02-29</span></code> exists in the time dimension.</p>
<p>When compared to a table in the database, a <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> instance does not have
to contain all of the database table’s columns. However, only the state of the
included columns will be compared. This is useful for excluding columns for which
the user does not know the state or which do not matter in the test, like an
automatically generated primary key or audit information such as a timestamp.</p>
</section>
<section id="variables">
<span id="sec-variables"></span><h2>Variables<a class="headerlink" href="#variables" title="Permalink to this heading">¶</a></h2>
<p>In some cases specific cells must be equal across different database
tables, but the exact values are unknown or do not matter. A prominent example is
when foreign keys are used. In DTT this is easy to state using variables. A variable
has a name prefixed by $ and can be used in any cell of a Drawn Table. The prefix
can be changed by passing an argument to <code class="xref py py-attr docutils literal notranslate"><span class="pre">variableprefix</span></code> in <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table" title="pygrametl.drawntabletesting.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>’s
constructor. DTT checks if the cells with the same variable contain
the same values in the database and fails the test if not. The code snippet below
shows an example of how to use variables to test that foreign keys are assigned
correctly.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pygrametl.drawntabletesting</span> <span class="k">as</span> <span class="nn">dtt</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">connectionwrapper</span><span class="p">()</span>

<span class="n">genre</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;genre&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| gid:int (pk)  | genre:text |</span>
<span class="s2">| ------------- | ---------- |</span>
<span class="s2">| $1            | Novel      |</span>
<span class="s2">| $2            | Comic      |&quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">book</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| bid:int (pk) | title:text             | gid:int (fk genre(gid)) |</span>
<span class="s2">| ------------ | ---------------------- | ----------------------- |</span>
<span class="s2">| 1            | Nineteen Eighty-Four   | $1                      |</span>
<span class="s2">| 2            | Calvin and Hobbes One  | $2                      |</span>
<span class="s2">| 3            | Calvin and Hobbes Two  | $2                      |&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here it is stated that the <code class="docutils literal notranslate"><span class="pre">gid</span></code> for <code class="docutils literal notranslate"><span class="pre">Nineteen</span> <span class="pre">Eighty-Four</span></code> in <code class="docutils literal notranslate"><span class="pre">book</span></code>
must match the <code class="docutils literal notranslate"><span class="pre">gid</span></code> for <code class="docutils literal notranslate"><span class="pre">Novel</span></code> in <code class="docutils literal notranslate"><span class="pre">genre</span></code>, while the <code class="docutils literal notranslate"><span class="pre">gid</span></code> for
<code class="docutils literal notranslate"><span class="pre">Calvin</span> <span class="pre">and</span> <span class="pre">Hobbes</span> <span class="pre">One</span></code> and <code class="docutils literal notranslate"><span class="pre">Calvin</span> <span class="pre">and</span> <span class="pre">Hobbes</span> <span class="pre">Two</span></code> in <code class="docutils literal notranslate"><span class="pre">book</span></code> must match
the <code class="docutils literal notranslate"><span class="pre">gid</span></code> for <code class="docutils literal notranslate"><span class="pre">Comic</span></code> in <code class="docutils literal notranslate"><span class="pre">genre</span></code>. If the variables with the same name do
not have matching values, the errors shown below are raised.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">AssertionError: Ambiguous values for $1; genre(row 0, column 0 gid) is 1 and book(row 0, column 2 gid) is 2</span>
<span class="go">...</span>
</pre></div>
</div>
<p>This error message is an excerpt from the output of a test case where
<code class="docutils literal notranslate"><span class="pre">genre</span></code> and <code class="docutils literal notranslate"><span class="pre">book</span></code> had their IDs defined in different orders. In this case,
the foreign key constraints were satisfied although <code class="docutils literal notranslate"><span class="pre">Nineteen</span> <span class="pre">Eighty-Four</span></code>
(wrongly) was referencing the genre <code class="docutils literal notranslate"><span class="pre">comic</span></code>. Thus, variables can test parts of the
ETL flow which cannot be verified by foreign keys as the latter only ensure that a
value is present.</p>
<p>Another example of using variables is shown below. Here the user verifies that
in a type-2 Slowly Changing Dimension, the timestamp set for <code class="docutils literal notranslate"><span class="pre">validto</span></code>
matches <code class="docutils literal notranslate"><span class="pre">validfrom</span></code> for the new version of the member. Thus, variables can be
used to efficiently test automatically generated values are correct.
It is also possible to specify that the value of a cell should not be included
in the comparison. This is done with the special variable <code class="docutils literal notranslate"><span class="pre">$_</span></code>. When compared
to any value, <code class="docutils literal notranslate"><span class="pre">$_</span></code> is always considered to be equal. In the example below,
the actual values of the primary key column are not taken into consideration.
<code class="docutils literal notranslate"><span class="pre">$_!</span></code> is a stricter version of <code class="docutils literal notranslate"><span class="pre">$_</span></code> which disallows <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pygrametl.drawntabletesting</span> <span class="k">as</span> <span class="nn">dtt</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">connectionwrapper</span><span class="p">()</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;address&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">| aid:int (pk) | dept:text | location:text           | validfrom:date | validto:date |</span>
<span class="s2">| ------------ | --------- | ----------------------- | -------------- | ------------ |</span>
<span class="s2">| $_           | CS        | Fredrik Bajers Vej 7    | 1990-01-01     | $1           |</span>
<span class="s2">| $_           | CS        | Selma Lagerløfs Vej 300 | $1             | NULL         |&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The methods <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.ensure" title="pygrametl.drawntabletesting.Table.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensure()</span></code></a> and <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.reset" title="pygrametl.drawntabletesting.Table.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code></a> may not be
called on a Drawn Table where any variables are used (this will raise an
error). This effectively means that variables can only be used when the
postcondition is specified. The reason is that DTT does not know which concrete
values to insert into the database for variables if they are used in
preconditions.</p>
</section>
<section id="tooling-support">
<h2>Tooling Support<a class="headerlink" href="#tooling-support" title="Permalink to this heading">¶</a></h2>
<p>A key benefit of DTT is the ability for users to effectively understand the
preconditions and postconditions of a test due to the visual representation
provided by the Drawn Tables. However, to gain the full benefit of Drawn
Tables, their columns must be aligned across rows as their content otherwise
becomes much more difficult to read. A very poorly formatted Drawn Table can be
seen below.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> bid:int (pk)    | title:text       | genre:text |
<span class="o">|</span> ----------------- |
<span class="o">|</span> 1     | Unknown    | Unknown |
<span class="o">|</span> 2 | Nineteen Eighty-Four | Novel     |
<span class="o">|</span> 3     | Calvin and Hobbes One     | Comic |
<span class="o">|</span> 4 | Calvin and Hobbes Two     | Comic |
<span class="o">|</span> 5        | The Silver Spoon | Cookbook |
</pre></div>
</div>
<p>It is clear from this example that poor formatting makes a Drawn Table harder
to read. However, as properly formatting each Drawn Table can be tedious, DTT
provides the script <code class="docutils literal notranslate"><span class="pre">formattable.py</span></code> that automates this task. The script
is designed to be interfaced with extensible text editors so users
can format a Drawn Table by simply placing the cursor anywhere on a Drawn Table
and executing the script. An automatically formatted version of the Drawn Table
from above can be seen below, and it is clear that this version of the Drawn
Table is much easier to read.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> bid:int (pk) | title:text            | genre:text |
<span class="o">|</span> ------------ | --------------------- | ---------- |
<span class="o">|</span> 1            | Unknown               | Unknown    |
<span class="o">|</span> 2            | Nineteen Eighty-Four  | Novel      |
<span class="o">|</span> 3            | Calvin and Hobbes One | Comic      |
<span class="o">|</span> 4            | Calvin and Hobbes Two | Comic      |
<span class="o">|</span> 5            | The Silver Spoon      | Cookbook   |
</pre></div>
</div>
<p>The following two functions demonstrate how <code class="docutils literal notranslate"><span class="pre">formattable.py</span></code> can be
integrated with GNU Emacs and Vim/NeoVim, respectively. However, <code class="docutils literal notranslate"><span class="pre">formattable.py</span></code> is
editor agnostic and the functions are simply intended as examples.</p>
<p>GNU Emacs</p>
<div class="highlight-elisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">dtt-align-table</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;Format the Drawn Table at point using an external Python script.&quot;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">interactive</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">save-buffer</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">shell-command</span><span class="w"></span>
<span class="w">   </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="s">&quot;python3 formattable.py &quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">buffer-file-name</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">number-to-string</span><span class="w"> </span><span class="p">(</span><span class="nv">line-number-at-pos</span><span class="p">))))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">revert-buffer</span><span class="w"> </span><span class="nb">:ignore-auto</span><span class="w"> </span><span class="nb">:noconfirm</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Vim and NeoVim</p>
<div class="highlight-vim notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="p">!</span> DTTAlignTable<span class="p">()</span>
    <span class="nb">write</span>
    <span class="k">call</span> system<span class="p">(</span><span class="s2">&quot;python3 formattable.py &quot;</span> . expand<span class="p">(</span><span class="s1">&#39;%:p&#39;</span><span class="p">)</span> . <span class="s2">&quot; &quot;</span> . line<span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
    edit<span class="p">!</span>
<span class="k">endfunction</span>
</pre></div>
</div>
</section>
<section id="drawn-table-testing-as-a-python-package">
<h2>Drawn Table Testing as a Python Package<a class="headerlink" href="#drawn-table-testing-as-a-python-package" title="Permalink to this heading">¶</a></h2>
<p>Using the presented constructs, users can efficiently define preconditions and
postconditions to test each part of their ETL flows.  DTT thus supports
creation of tests during development, e.g., using test-driven development (TDD).
A full example using both DTT and Python’s <code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> module is shown below.</p>
<p>When using <code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code>, a class must be defined for each set of tests. It
is natural to group tests for a dimension into a class such that they can share a
Drawn Table defining the precondition. A class using DTT to test the ETL flow for the
<code class="docutils literal notranslate"><span class="pre">book</span></code> dimension is defined on Line 1. It inherits from <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code>
as required by <code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code>. Two methods are then overridden <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">pygrametl.drawntabletesting</span> <span class="k">as</span> <span class="nn">dtt</span>


<span class="k">class</span> <span class="nc">BookStateTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cw</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">connectionwrapper</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">initial</span> <span class="o">=</span> <span class="n">dtt</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s2">&quot;book&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        | bid:int (pk) | title:text            | genre:text |</span>
<span class="s2">        | ------------ | --------------------- | ---------- |</span>
<span class="s2">        | 1            | Unknown               | Unknown    |</span>
<span class="s2">        | 2            | Nineteen Eighty-Four  | Novel      |</span>
<span class="s2">        | 3            | Calvin and Hobbes One | Comic      |</span>
<span class="s2">        | 4            | The Silver Spoon      | Cookbook   |&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_insertNew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial</span> <span class="o">+</span> <span class="s2">&quot;| 5 | Calvin and Hobbes Two | Comic |&quot;</span>
        <span class="n">newrows</span> <span class="o">=</span> <span class="n">expected</span><span class="o">.</span><span class="n">additions</span><span class="p">()</span>
        <span class="n">etl</span><span class="o">.</span><span class="n">executeETLFlow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cw</span><span class="p">,</span> <span class="n">newrows</span><span class="p">)</span>
        <span class="n">expected</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_insertExisting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bid&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;book&#39;</span><span class="p">:</span> <span class="s1">&#39;Calvin and Hobbes One&#39;</span><span class="p">,</span> <span class="s1">&#39;genre&#39;</span><span class="p">:</span> <span class="s1">&#39;Comic&#39;</span><span class="p">}</span>
        <span class="n">etl</span><span class="o">.</span><span class="n">executeETLFlow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cw</span><span class="p">,</span> <span class="p">[</span><span class="n">row</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">()</span>
</pre></div>
</div>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code> is executed before the tests (methods starting
with <code class="xref py py-attr docutils literal notranslate"><span class="pre">test_</span></code>) in the class are executed. The method requests a database
connection from DTT on Line 4 and defines a Drawn Table with the initial state
of the dimension in Line 5. By creating them in <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code>, they are
only initialized once and can be reused for each test. To ensure the tests do
not affect each other, which would make the result depend on the execution
order of the tests, the <code class="docutils literal notranslate"><span class="pre">book</span></code> table in the database is reset before each
test by <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>. Then on Line 15 and Line 21, the tests are implemented
as separate methods. <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_insertNew()</span></code> tests that a row that currently
does not exist in <code class="docutils literal notranslate"><span class="pre">book</span></code> is inserted correctly, while <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_insertExisting()</span></code>
ensures that an already existing row does not become duplicated. In this example,
both of these tests invoke the user’s ETL flow by calling the user-defined method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">executeETLFlow()</span></code>. As stated, the ETL flow may be implemented in Python,
another programming language, or any other program.</p>
</section>
<section id="drawn-table-testing-as-a-stand-alone-tool">
<h2>Drawn Table Testing as a Stand-Alone Tool<a class="headerlink" href="#drawn-table-testing-as-a-stand-alone-tool" title="Permalink to this heading">¶</a></h2>
<p>DTT can also be used without doing any programming. To enable this, DTT provides
a program with a command-line interface named <code class="docutils literal notranslate"><span class="pre">dttr</span></code> (for DTT Runner).
Internally, <code class="docutils literal notranslate"><span class="pre">dttr</span></code> uses the DTT module described above. <code class="docutils literal notranslate"><span class="pre">dttr</span></code> uses test
files, which have the <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> suffix, to specify preconditions and/or
postconditions. A test file only contains Drawn Tables but not any Python code.
However, a configuration file named <code class="docutils literal notranslate"><span class="pre">config.py</span></code> can be created in the same
folders as the <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> files to define PEP 249 connections (i.e., in addition
to the default in-memory SQlite database) and data sources (support for CSV and
SQL is provided by <code class="docutils literal notranslate"><span class="pre">dttr</span></code>) for use in the tests. An example of a test file is
given below. This file only contains one precondition (i.e., a Drawn Table with
a name, but without an assert, on the first line) on Line 1–4 and one
postcondition (i.e., a Drawn Table with both a name and an assert on the first
line) on Line 6–13). This structure is, however, not a requirement as a <code class="docutils literal notranslate"><span class="pre">.dtt</span></code>
file can contain any number of preconditions and/or postconditions.</p>
<div class="highlight-rst notranslate"><div class="highlight"><pre><span></span>book
<span class="o">|</span> bid:int (pk) | title:text            | genre:text |
<span class="o">|</span> ------------ | --------------------- | ---------- |
<span class="o">|</span> 1            | Unknown               | Unknown    |

book, equal
<span class="o">|</span> bid:int (pk) | title:text            | genre:text |
<span class="o">|</span> ------------ | --------------------- | ---------- |
<span class="o">|</span> 1            | Unknown               | Unknown    |
<span class="o">|</span> 2            | Nineteen Eighty-Four  | Novel      |
<span class="o">|</span> 3            | Calvin and Hobbes One | Comic      |
<span class="o">|</span> 4            | Calvin and Hobbes Two | Comic      |
<span class="o">|</span> 5            | The Silver Spoon      | Cookbook   |
</pre></div>
</div>
<p>To specify a precondition, first the name of the table must be given; in the
example above that is <code class="docutils literal notranslate"><span class="pre">book</span></code>. As <code class="docutils literal notranslate"><span class="pre">dttr</span></code> uses the DTT module internally, it
uses an in-memory SQLite database as the test database by default. Additional
databases can be added by assigning PEP 249 connections to variables in the
configuration file. To use a connection from the configuration file, the table
name must be followed by an <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> sign and then the name of the connection to
use for this table, e.g., <code class="docutils literal notranslate"><span class="pre">book&#64;targetdw</span></code>. After the table name, a Drawn Table
must be specified (Lines 2–4 in the example above). Like for any other Drawn
Table, the header must be given first, then the delimiter, and last the rows. To
mark the end of the precondition, an empty line is specified (Line 5).</p>
<p>To specify a postcondition, a table name must be given first. The table name must
then followed by a comma and the name of the assertion to use as shown in Line
6 in the example. The table name for the postcondition is <code class="docutils literal notranslate"><span class="pre">book</span></code> like for the
precondition, but they may also be different. For example, the precondition
could define the initial state for <code class="docutils literal notranslate"><span class="pre">inputdata&#64;sourcedb</span></code> and the postcondition
could define the expected state for <code class="docutils literal notranslate"><span class="pre">book&#64;targetdw</span></code>. As already mentioned,
the name of the table to use for the postcondition is followed by a comma and
the assertion to use, i.e., <code class="docutils literal notranslate"><span class="pre">equal</span></code> in this example.  One can also use the
other assertions in DTT: <code class="docutils literal notranslate"><span class="pre">disjoint</span></code> and <code class="docutils literal notranslate"><span class="pre">subset</span></code>.  Finally in Line 7–13
the actual Drawn Table is given in the same way as for the precondition.
The Drawn Table in the postcondition may also use variables. Note that a test
does not require both a precondition and a postcondition, both are optional.
It is thus, e.g., possible to create a test file where no precondition is set,
but the postcondition still is asserted after executing the ETL flow. Also, as
stated, a <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> file can contain any number of preconditions and postconditions.</p>
<p>For tests that require more data than what is feasible to embed directly in a
Drawn Table, data in an external file or database can be added to a Drawn Table
by specifying an external data source as its last line. For example, by adding
the line <code class="docutils literal notranslate"><span class="pre">csv</span> <span class="pre">bookdata.csv</span> <span class="pre">,</span></code> the contents of the CSV file <code class="docutils literal notranslate"><span class="pre">bookdata.csv</span></code>
is added to the Drawn Table with <code class="docutils literal notranslate"><span class="pre">,</span></code> used as field separator, in addition to
any rows drawn as part of the Drawn Table. By adding <code class="docutils literal notranslate"><span class="pre">sql</span> <span class="pre">oltp</span> <span class="pre">SELECT</span> <span class="pre">bid,</span>
<span class="pre">title,</span> <span class="pre">genre</span> <span class="pre">FROM</span> <span class="pre">book</span></code> as the last line, all rows of the table <code class="docutils literal notranslate"><span class="pre">book</span></code> from
the PEP 249 connection <code class="docutils literal notranslate"><span class="pre">oltp</span></code> are added to the Drawn Table. This is also
extensible through the configuration file such that support for other sources
of data, e.g., XML or a NoSQL DBMS like MongoDB can be added. This is done by
creating a function in the configuration file. If, for example, the line <code class="docutils literal notranslate"><span class="pre">xml</span>
<span class="pre">teacher</span> <span class="pre">8</span></code> is found in a <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> file, <code class="docutils literal notranslate"><span class="pre">dttr</span></code> looks for the function
<code class="docutils literal notranslate"><span class="pre">xml</span></code> in the configuration file and executes it with the arguments
<code class="docutils literal notranslate"><span class="pre">'teacher'</span></code> and <code class="docutils literal notranslate"><span class="pre">'8'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">dttr</span></code> can be invoked from the command line as shown below. Note that the ETL
program to test and its arguments simply are given to <code class="docutils literal notranslate"><span class="pre">dttr</span></code> as arguments
(<code class="docutils literal notranslate"><span class="pre">–-etl</span> <span class="pre">...</span></code>). Thus, any ETL program can be invoked.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./dttr.py --etl <span class="s2">&quot;python3 myetl --loaddim book&quot;</span>
</pre></div>
</div>
<p>When executed, <code class="docutils literal notranslate"><span class="pre">dttr</span></code> by default looks for all <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> test files in the
current working directory, but optional arguments allow the user to select
which files to consider (see <code class="docutils literal notranslate"><span class="pre">dttr</span> <span class="pre">-h</span></code> for more information). <code class="docutils literal notranslate"><span class="pre">dttr</span></code> then
reads all relevant test files. Then the preconditions from these files are set.
This is done using the DTT’s <a class="reference internal" href="../api/drawntabletesting.html#pygrametl.drawntabletesting.Table.ensure" title="pygrametl.drawntabletesting.Table.ensure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ensure</span></code></a> method such that
each table is created and its data is inserted if necessary. If a table with
the given name already exists and has differing content, an error will be raised
and the table will not be updated. After the preconditions have been set, the ETL
flow is started. How to execute the ETL flow is specified using the <code class="docutils literal notranslate"><span class="pre">--etl</span></code> flag
as shown above. When the ETL flow has finished, all postconditions are asserted
and any violation raises an error. If multiple occurrences of the same variable
have different values, an error will also be raised, no matter if the variables
are in the same or different <code class="docutils literal notranslate"><span class="pre">.dtt</span></code> files. It is thus, e.g., possible to have
a test file for the fact table and another test file for a dimension table and
still ensure that an inserted fact’s foreign key references a specific dimension
member.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pygrametl</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/install.html">Install Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/beginner.html">Beginner Guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasources.html">Data Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimensions.html">Dimensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="facttables.html">Fact Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="bulkloading.html">Bulk Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="jython.html">Jython</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Testing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/pygrametl.html">pygrametl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/datasources.html">datasources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/tables.html">tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/parallel.html">parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/jdbcconnectionwrapper.html">JDBCConnectionWrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/jythonmultiprocessing.html">jythonmultiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/aggregators.html">aggregators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/steps.html">steps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/fifodict.html">FIFODict</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/drawntabletesting.html">drawntabletesting</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="jython.html" title="previous chapter">Jython</a></li>
      <li>Next: <a href="../api/pygrametl.html" title="next chapter">pygrametl</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2009 - 2022, Aalborg University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/examples/testing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>